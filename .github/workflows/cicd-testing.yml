name: GHCR - Install SD-Core 5G

on:
  workflow_dispatch:
    inputs:
      server_ip:
        description: 'The server IP address'
        required: true
        default: '10.176.27.188'
      port:
        description: "The port to deploy the application on 8080"
        required: true
        default: "8080"
      branch_name:
        description: 'The branch name to use'
        required: true
        default: 'main'
      smoke_test:
        description: 'Run Smoke Test'
        required: true
        default: 'true'
        type: boolean
      sanity_test:
        description: 'Run Sanity Test'
        required: true
        default: 'true'
        type: boolean

jobs:
  install:
    runs-on: [self-hosted]

    steps:
      - name: Checkout Code
        uses: actions/checkout@v2

      - name: Set Up Variables
        run: |
          echo "SERVER_IP=${{ github.event.inputs.server_ip }}" >> $GITHUB_ENV
          echo "BRANCH_NAME=${{ github.event.inputs.branch_name }}" >> $GITHUB_ENV
          echo "SMOKE_TEST=${{ github.event.inputs.smoke_test }}" >> $GITHUB_ENV
          echo "SANITY_TEST=${{ github.event.inputs.sanity_test }}" >> $GITHUB_ENV

      - name: Cache jq installation
        uses: actions/cache@v2
        with:
          path: /usr/bin/jq
          key: ${{ runner.os }}-jq-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-jq-

      - name: Fetch Jenkins Crumb
        run: |
          # Fetch the Jenkins crumb
          CRUMB=$(curl -u $USERNAME:$TOKEN -s "http://$JENKINS_URL/crumbIssuer/api/json" | jq -r '.crumb')
          
          # Check if the crumb was fetched successfully
          if [ -z "$CRUMB" ]; then
            echo "Failed to get Jenkins crumb"
            exit 1
          fi
          
          echo "CRUMB=$CRUMB" >> $GITHUB_ENV

      - name: Trigger Jenkins Parameterized Job
        run: |
          set -e
          JENKINS_URL="http://10.176.27.188:8080/"
          JOB_NAME="ABot-SDCORE-CI-Pipeline"
          USERNAME="admin"
          TOKEN="ce71fdbd78e446f98c038dbdc78e6619"
          SERVER_IP_ENCODED=${{ github.event.inputs.server_ip }}
          PORT_ENCODED=${{ github.event.inputs.port }}
          BRANCH_NAME_ENCODED=${{ github.event.inputs.branch_name }}
          SMOKE_TEST_ENCODED=${{ github.event.inputs.smoke_test }}
          SANITY_TEST_ENCODED=${{ github.event.inputs.sanity_test }}
          
          TRIGGER_RESPONSE=$(curl -v -X POST -u $USERNAME:$TOKEN \
               -H "Jenkins-Crumb: $CRUMB" \
               "${JENKINS_URL}job/${JOB_NAME}/buildWithParameters?SERVER_IP=${SERVER_IP_ENCODED}&PORT=${PORT_ENCODED}&BRANCH_NAME=${BRANCH_NAME_ENCODED}&Smoke_Test=${SMOKE_TEST_ENCODED}&Sanity_Test=${SANITY_TEST_ENCODED}" \
                -i)
          echo "Full response from Jenkins: $TRIGGER_RESPONSE"
          QUEUE_URL=$(echo "$TRIGGER_RESPONSE" | grep -Fi Location | awk '{print $2}' | tr -d '\r')
          if [ -z "$QUEUE_URL" ]; then
            echo "Failed to trigger Jenkins job. Queue URL not found."
            exit 1
          fi
          echo "Triggered Jenkins job. Queue URL: $QUEUE_URL"
          echo "queue_url=$QUEUE_URL" >> $GITHUB_ENV

      - name: Remove Conflicting Packages
        run: |
          sudo apt-get remove --purge -y containerd
          sudo apt-get autoremove -y
          sudo apt-mark unhold containerd || true  # Ensure no held packages
          sudo apt-get update -y

      - name: Prerequisites environment
        run: |
           sudo ufw status
           systemctl status systemd-networkd.service

      - name: Install Prerequisites
        run: |
          if [ ! -f /usr/share/keyrings/docker-archive-keyring.gpg ]; then
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
          else
            echo "Docker keyring already exists. Skipping creation."
          fi
          sudo chmod a+r /usr/share/keyrings/docker-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
          sudo apt-get update -y
          sudo apt-get install -y containerd.io
          sudo apt-get install -y git curl make net-tools pipx python3-venv sshpass netplan.io iptables jq sed
          pipx install --include-deps ansible || true  # Ignore if already installed
          pipx ensurepath
          make --version  # Verify make installation
          echo "PATH=$PATH:/usr/bin:$HOME/.local/bin" >> $GITHUB_ENV
          source $GITHUB_ENV  # Ensure new PATH is applied

      - name: Debug PATH and Installed Tools
        run: |
          echo "Current PATH: $PATH"
          which sed || echo "sed not found"
          ls -l /usr/bin/sed || echo "/usr/bin/sed not found"

      - name: Installation of Aether OnRamp
        run: |
          git clone --recursive https://github.com/opennetworkinglab/aether-onramp.git
          cd aether-onramp

      - name: Set up network variables
        run: |
          echo "DATA_IFACE=ens18" >> $GITHUB_ENV
          echo "AMF_IP=10.176.27.188" >> $GITHUB_ENV

      - name: Update Configuration Files
        shell: bash
        run: |
          # Replace content of line 2 with the new node1 IP and credentials
          sed -i '2s/.*/node1 ansible_host=10.176.27.188 ansible_user=ios5gn ansible_password=ios5gn ansible_sudo_pass=ios5gn/' hosts.ini
          sed -i '3s/^/#/' hosts.ini
          sed -i '10s/^/#/' hosts.ini
          # Verify the updated hosts.ini content
          echo "Updated hosts.ini content:"
          cat hosts.ini

      - name: Set up Docker authentication for GHCR
        run: |
          sudo docker login ghcr.io -u "${{ secrets.GHCRUSER }}" --password-stdin <<< "${{ secrets.GHCRPASS }}"

      - name: Install Kubernetes
        shell: bash
        run: |
          make aether-k8s-install  # Running from repo home

      - name: Install SD-Core
        run: |
          make aether-5gc-install  # Running from repo home
          kubectl get pods -n omec

      # Validation step(whether the deployment and installation of the SD-Core 5G application on a specified server are successful)
      - name: Validate Kubernetes Pods
        run: |
          kubectl get pods -n omec
          kubectl wait --for=condition=Ready pods --all -n omec --timeout=300s
          NOT_READY=$(kubectl get pods -n omec --no-headers | grep -v Running | wc -l)
          if [ "$NOT_READY" -ne "0" ]; then
            echo "Some pods are not running or ready."
            exit 1
          fi
          echo "All pods in the omec namespace are running and ready."

      - name: Test Application Endpoints
        run: |
          AMF_ENDPOINT="http://${{ github.event.inputs.server_ip }}:${{ github.event.inputs.port }}/amf"
          curl -f $AMF_ENDPOINT || { echo "AMF endpoint is not accessible."; exit 1; }
          echo "AMF endpoint is accessible."

      - name: Inspect Pod Logs
        run: |
          PODS=$(kubectl get pods -n omec --no-headers -o custom-columns=":metadata.name")
          for POD in $PODS; do
            echo "Checking logs for pod: $POD"
            kubectl logs $POD -n omec | grep -i error && { echo "Errors found in logs of pod $POD"; exit 1; }
          done
          echo "No errors found in pod logs."

      - name: Final Status Check
        run: |
          echo "SD-Core 5G deployment and installation completed successfully!"
